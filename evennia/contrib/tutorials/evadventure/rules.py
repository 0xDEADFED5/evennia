"""
MUD ruleset based on the _Knave_ OSR tabletop RPG by Ben Milton (modified for MUD use).

The rules are divided into three parts:

- Character generation - these are rules only used when creating a character.
- Improvement - these are rules used with experience to improve the character
    over time.
- Actions - all in-game interactions (making use of the character's abilities)
  are defined as discreet _actions_ in the game. An action is the smallest rule
  unit to accomplish something with rule support. While in a tabletop game you
  have a human game master to arbitrate, the computer requires exactness. While
  free-form roleplay is also possible, only the actions defined here will have a
  coded support.

"""
from dataclasses import dataclass
from .utils import roll
from .random_tables import character_generation as chargen_table


# Basic rolls

def saving_throw(bonus, advantage=False, disadvantage=False):
    """
    To save, roll d20 + relevant Attrribute bonus > 15 (always 15).

    Args:
        advantage (bool): Roll 2d20 and use the bigger number.
        disadvantage (bool): Roll 2d20 and use the smaller number.

    Returns:
        bool: If the save was passed or not.

    Notes:
        Advantage and disadvantage cancel each other out.

    Example:
        Trying to overcome the effects of poison, roll d20 + Constitution-bonus above 15.

    """
    if not (advantage or disadvantage) or (advantage and disadvantage):
        # normal roll
        dice_roll = roll("1d20")
    elif advantage:
        dice_roll = max(roll("1d20"), roll("1d20"))
    else:
        dice_roll = min(roll("1d20"), roll("1d20"))
    return (dice_roll + bonus) > 15


def roll_attribute_bonus():
    """
    For the MUD version, we use a flat bonus and let the user redistribute it. This
    function (unused by default) implements the original Knave random generator for
    the Attribute bonus, if you prefer producing more 'unbalanced' characters.

    The Attribute bonus is generated by rolling the lowest value of 3d6.

    Returns:
        int: The randomly generated Attribute bonus.

    """
    return min(roll("1d6"), roll("1d6"), roll("1d6"))


def roll_random_table(dieroll, table, table_choices):
    """
    Make a roll on a random table.

    Args:
        dieroll (str): The dice to roll, like 1d6, 1d20, 3d6 etc).
        table_choices (iterable): If a list of single elements, the die roll
            should fully encompass the table, like a 1d20 roll for a table
            with 20 elements. If each element is a tuple, the first element
            of the tuple is assumed to be a string 'X-Y' indicating the
            range of values that should match the roll.

    Returns:
        Any: The result of the random roll.

    Example:
        `roll table_choices = [('1-5', "Blue"), ('6-9': "Red"), ('10', "Purple")]`

    Notes:
        If the roll is outside of the listing, the closest edge value is used.

    """
    roll_result = roll(dieroll)

    if isinstance(table_choices[0], (tuple, list)):
        # tuple with range conditional, like ('1-5', "Blue") or ('10', "Purple")
        max_range = -1
        min_range = 10**6
        for (valrange, choice) in table_choices:

            minval, *maxval = valrange.split('-', 1)
            minval = abs(int(minval))
            maxval = abs(int(maxval[0]) if maxval else minval)

            # we store the largest/smallest values so far in case we need to use them
            max_range = max(max_range, maxval)
            min_range = min(min_range, minval)

            if minval <= roll_result <= maxval:
                return choice

        # if we have no result, we are outside of the range, we pick the edge values. It is also
        # possible the range contains 'gaps', but that'd be an error in the random table itself.
        if roll_result > max_range:
            return max_range
        else:
            return min_range
    else:
        # regular list - one line per value.
        roll_result = max(1, min(len(table_choices), roll_result))
        return table_choices[roll_result - 1]


# character generation

@dataclass
class CharAttribute:
    """
    A character Attribute, like strength or wisdom, has a _bonus_, used
    to improve the result of doing a related action. It also has a _defense_ value
    which is always 10 points higher than the bonus. For example, to attack
    someone, you'd have to roll d20 + `strength bonus` to beat the `strength defense`
    of the enemy.

    """
    bonus: str = 0

    @property
    def defense(self):
        return bonus + 10


class CharacterGeneration:
    """
    This collects all the rules for generating a new character. An instance of this class can be
    used to track all the stats during generation and will be used to apply all the data to the
    character at the end. This class instance can also be saved temporarily to make sure a user
    is not losing their half-created character.

    Note:
        Unlike standard Knave, characters will come out more similar here. This is because in
        a table top game it's fun to roll randomly and have to live with a crappy roll - but
        online players can (and usually will) just disconnect and reroll until they get values
        they are happy with.

        So, in standard Knave, the character's attribute bonus is rolled randomly and will give a
        value 1-6; and there is no guarantee for 'equal' starting characters. Instead we
        homogenize the results to a flat +2 bonus and let people redistribute the
        points afterwards. This also allows us to show off some more advanced concepts in the
        chargen menu, but you can also easily make it random like in base Knave by using the
        (currently unused, but included) `roll_attribute_bonus` function above to get the bonus
        instead of the flat +2.

        In the same way, Knave uses a d8 roll to get the initial hit points. Instead we use a
        flat max of 8 HP to start, in order to give players a little more survivability.

        We *will* roll random start equipment though. Contrary to standard Knave, we'll also
        randomly assign the starting weapon among a small selection of equal-dmg weapons (since
        there is no GM to adjudicate a different choice).

    """
    def __init__(self):
        """
        Initialize starting values

        """
        # name will likely be modified later
        self.name = roll_random_table('1d282', chargen_table['name'])

        # base attribute bonuses
        self.strength = CharAttribute(bonus=2)
        self.dexterity = CharAttribute(bonus=2)
        self.constitution = CharAttribute(bonus=2)
        self.intelligence = CharAttribute(bonus=2)
        self.wisdom = CharAttribute(bonus=2)
        self.charisma = CharAttribute(bonus=2)

        self.armor = CharAttribute(bonus=1)  # un-armored default

        # physical attributes (only for rp purposes)
        self.physique = roll_random_table('1d20', chargen_table['physique'])
        self.face = roll_random_table(chargen_table['1d20', 'face'])
        self.skin = roll_random_table(chargen_table['1d20', 'skin'])
        self.hair = roll_random_table(chargen_table['1d20', 'hair'])
        self.clothing = roll_random_table(chargen_table['1d20', 'clothing'])
        self.virtue = roll_random_table(chargen_table['1d20', 'virtue'])
        self.vice = roll_random_table(chargen_table['1d20', 'vice'])
        self.background = roll_random_table(chargen_table['1d20', 'background'])
        self.misfortune = roll_random_table(chargen_table['1d20', 'misfortune'])
        self.alignment = roll_random_table(chargen_table['1d20', 'alignment'])

        # same for all
        self.exploration_speed = 120
        self.combat_speed = 40
        self.hp = 0
        self.xp = 0
        self.level = 1

        # random equipment
        self.armor = roll_random_table('1d20', chargen_table['armor'])

        _helmet_and_shield = roll_random_table('1d20', chargen_table["helmets and shields"])
        self.helmet = "helmet" if "helmet" in _helmet_and_shield else "none"
        self.shield = "shield" if "shield" in _helmet_and_shield else "none"

        self.weapon = roll_random_table(chargen_table['1d20', "starting_weapon"])

        self.equipment = [
            "ration",
            "ration",
            roll_random_table(chargen_table['1d20', "dungeoning gear"]),
            roll_random_table(chargen_table['1d20', "dungeoning gear"]),
            roll_random_table(chargen_table['1d20', "general gear 1"]),
            roll_random_table(chargen_table['1d20', "general gear 2"]),
        ]

    def adjust_attribute(self, source_attribute, target_attribute, value):
        """
        Redistribute bonus from one attribute to another. The resulting values
        must not be lower than +1 and not above +6.

        Args:
            source_attribute (str): The name of the attribute to deduct bonus from, like 'strength'
            target_attribute (str): The attribute to give the bonus to, like 'dexterity'.
            value (int): How much to change. This is always 1 for the current chargen.

        Raises:
            ValueError: On input error, using invalid values etc.

        Notes:
            We assume the strings are provided by the chargen, so we don't do
            much input validation here, we do make sure we don't overcharge ourselves though.

        """
        # we use getattr() to fetch the CharaAttribute of e.g. the .strength property etc
        source_current_bonus = getattr(self, source_attribute).bonus
        target_current_bonus = getattr(self, target_attribute).bonus

        if source_current_val - value < 1:
            raise ValueError(f"You can't reduce the {source_attribute} bonus below +1.")
        if target_current_val + value > 6:
            raise ValueError(f"You can't increase the {target_attribute} bonus above +6.")

        # all is good, apply the change.
        setattr(self, source_attribute, CharAttribute(bonus=source_current_val - value))
        setattr(self, target_attribute, CharAttribute(bonus=source_current_val + value))

    def apply(self, character):
        """
        Once the chargen is complete, call this to transfer all the data to the character
        permanently.

        """
